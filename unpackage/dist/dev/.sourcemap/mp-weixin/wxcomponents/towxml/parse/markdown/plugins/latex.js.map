{"version":3,"file":"latex.js","sources":["wxcomponents/towxml/parse/markdown/plugins/latex.js"],"sourcesContent":["const config = require('../../../config');\n\n// Test if potential opening or closing delimieter\n// Assumes that there is a \"$\" at state.src[pos]\nfunction isValidDelim(state, pos) {\n    var prevChar, nextChar,\n        max = state.posMax,\n        can_open = true,\n        can_close = true;\n\n    prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;\n    nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1;\n\n    // Check non-whitespace conditions for opening and closing, and\n    // check that closing delimeter isn't followed by a number\n    if (prevChar === 0x20/* \" \" */ || prevChar === 0x09/* \\t */ ||\n            (nextChar >= 0x30/* \"0\" */ && nextChar <= 0x39/* \"9\" */)) {\n        can_close = false;\n    }\n    if (nextChar === 0x20/* \" \" */ || nextChar === 0x09/* \\t */) {\n        can_open = false;\n    }\n\n    return {\n        can_open: can_open,\n        can_close: can_close\n    };\n}\n\nfunction math_inline(state, silent) {\n    var start, match, token, res, pos, esc_count;\n\n    if (state.src[state.pos] !== \"$\") { return false; }\n\n    res = isValidDelim(state, state.pos);\n    if (!res.can_open) {\n        if (!silent) { state.pending += \"$\"; }\n        state.pos += 1;\n        return true;\n    }\n\n    // First check for and bypass all properly escaped delimieters\n    // This loop will assume that the first leading backtick can not\n    // be the first character in state.src, which is known since\n    // we have found an opening delimieter already.\n    start = state.pos + 1;\n    match = start;\n    while ( (match = state.src.indexOf(\"$\", match)) !== -1) {\n        // Found potential $, look for escapes, pos will point to\n        // first non escape when complete\n        pos = match - 1;\n        while (state.src[pos] === \"\\\\\") { pos -= 1; }\n\n        // Even number of escapes, potential closing delimiter found\n        if ( ((match - pos) % 2) == 1 ) { break; }\n        match += 1;\n    }\n\n    // No closing delimter found.  Consume $ and continue.\n    if (match === -1) {\n        if (!silent) { state.pending += \"$\"; }\n        state.pos = start;\n        return true;\n    }\n\n    // Check if we have empty content, ie: $$.  Do not parse.\n    if (match - start === 0) {\n        if (!silent) { state.pending += \"$$\"; }\n        state.pos = start + 1;\n        return true;\n    }\n\n    // Check for valid closing delimiter\n    res = isValidDelim(state, match);\n    if (!res.can_close) {\n        if (!silent) { state.pending += \"$\"; }\n        state.pos = start;\n        return true;\n    }\n\n    if (!silent) {\n        token         = state.push('math_inline', 'math', 0);\n        token.markup  = \"$\";\n        token.content = state.src.slice(start, match);\n    }\n\n    state.pos = match + 1;\n    return true;\n}\n\nfunction math_block(state, start, end, silent){\n    var firstLine, lastLine, next, lastPos, found = false, token,\n        pos = state.bMarks[start] + state.tShift[start],\n        max = state.eMarks[start]\n\n    if(pos + 2 > max){ return false; }\n    if(state.src.slice(pos,pos+2)!=='$$'){ return false; }\n\n    pos += 2;\n    firstLine = state.src.slice(pos,max);\n\n    if(silent){ return true; }\n    if(firstLine.trim().slice(-2)==='$$'){\n        // Single line expression\n        firstLine = firstLine.trim().slice(0, -2);\n        found = true;\n    }\n\n    for(next = start; !found; ){\n\n        next++;\n\n        if(next >= end){ break; }\n\n        pos = state.bMarks[next]+state.tShift[next];\n        max = state.eMarks[next];\n\n        if(pos < max && state.tShift[next] < state.blkIndent){\n            // non-empty line with negative indent should stop the list:\n            break;\n        }\n\n        if(state.src.slice(pos,max).trim().slice(-2)==='$$'){\n            lastPos = state.src.slice(0,max).lastIndexOf('$$');\n            lastLine = state.src.slice(pos,lastPos);\n            found = true;\n        }\n\n    }\n\n    state.line = next + 1;\n\n    token = state.push('math_block', 'math', 0);\n    token.block = true;\n    token.content = (firstLine && firstLine.trim() ? firstLine + '\\n' : '')\n    + state.getLines(start + 1, next, state.tShift[start], true)\n    + (lastLine && lastLine.trim() ? lastLine : '');\n    token.map = [ start, state.line ];\n    token.markup = '$$';\n    return true;\n}\n\nmodule.exports = md => {\n    var inlineRenderer = function(tokens, idx){\n      return `<latex value=\"${encodeURIComponent(tokens[idx].content).replace(/'/g,'%27')}\" type=\"line\"></latex>`;\n    };\n\n    var blockRenderer = function(tokens, idx){\n      return `<latex value=\"${encodeURIComponent(tokens[idx].content).replace(/'/g, '%27')}\" type=\"block\"></latex>`;\n    };\n\n    md.inline.ruler.after('escape', 'math_inline', math_inline);\n    md.block.ruler.after('blockquote', 'math_block', math_block, {\n        alt: [ 'paragraph', 'reference', 'blockquote', 'list' ]\n    });\n    md.renderer.rules.math_inline = inlineRenderer;\n    md.renderer.rules.math_block = blockRenderer;\n};"],"names":["require$$0"],"mappings":"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"}